# 解释与编译

* 解释	**程序和源程序参与程序的运行**，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序 ,如html,python

  * 词法、语法、语义分析

    

* 编译:  运行的是与源程序等价的目标程序，源程序和编译程序都**不再参与**目标程序的执行过程；

  * 词法分析、语法分析、语义分析、~~中间代码生成、代码优化~~、目标代码生成
  * **中间代码生成和代码优化不是必须****
  * **出错处理和符号表管理**
    * 符号表记录源程序中各个符号的信息，以辅助语义的正确性检查和代码生成，符号表的建立可以始于词法分析阶段，也可以放到语法分析和语义分析阶段，但符号表的使用有时会延续到目标代码运行阶段。



* 词法:    非法字符/关键字/变量是否被定义或声明

* 语法:    语法结构,if endif不匹配

* 语义     动态语义:死循环/逻辑错误 ,强制转换

  ​			静态语义 ,a/b ,b=0
  
  
  
  编译过程中进行的语法分析主要是分析（D）
  
  A.源程序中的标识符是否合法     B.程序语句的含义是否合法
  
  C.程序语句的结构是否合法      D.表达式的类型是否合法
  
  

![image-20200823214449647](image.assets/image-20200823214449647.png)



# 文法



有序四元组G=(V ,T ,S ,P)

V	非终结符 ,类似于占位符 ,不是语言组成部分 ,不是最终结果

T	终结符	是最终结果	V交T =空集

S	起始符	语言的开始符号

P	产生式	用终结符替代非终结符的规则 ,如a->b



* 闭包			A+	1~n个a的并集
* 正则闭包	A*	0~n个a的并集

![](image.assets/文法类型.png)

0型 短语文法         ->图灵机

1型 上下文有关文法->线性界线自动机

2             无关     ->非确定的下推自动机

3    正规文法          ->有限自动机





设某语言的语法规则用上下文无关文法G=(N，T，P，S)表示，其中N是非终结符号的集合，T是终结符号的集合，P是产生式集合，S是开始符号，令V=NUT,那么符合该语言的句子是（50)。

(50)A.从S出发推导的、仅包含T中符号的符号串

B.从N中符号出发推导的、仅包含T中符号的符号串	

C.从S出发推导的、包含V中符号的符号串

 	D.从N中符号出发推导的、包含V中符号的符号串

***\*【答案】A\****

一个文法的语言是该文法能产生的句子的集合。一个文法产生的句子是从文法开始符号出发推导出的所有终结符号串。





# 语法推导树

推导树以S起始符为根结点

每个结点都有一个标记 ,此标记是V的一个符号



![image-20200823220759230](image.assets/image-20200823220759230.png)

由题得S->Aas     S->a      A->SbA   A->SS    A->ba

**V=a,b 非终结符	T=S,A 终结符**	

开始推导

S->aAS,又因为A->SbA,所以S->a(SbA)S

又因为S->a,所以S-> a(abA)a->aabAa









# 有限自动机 (词法分析)

![image-20200823222142148](image.assets/image-20200823222142148.png)

能用闭包等符号表示出来的是**确定的有限自动机**







# 正规式

![image-20200823222524296](image.assets/image-20200823222524296.png)



# 数据类型与程序控制结构



顺序结构	选择结构	循环结构



# 后缀表达式

转化为二叉树 ,再后序遍历

![image-20200823224059841](image.assets/image-20200823224059841.png)



## 中间代码

后缀式，三元式，四元式和树









# 程序语言特点

![image-20200823230756007](image.assets/image-20200823230756007.png)

c语言   编译型   全局/静态局部/静态全局变量都放在静态数据存储区

**php 动态网页     不是标记语言**



标记语言常用于描述格式化和链接

脚本语言采用解释方式实现,代表一套与程序设计语言不同的协议,牺牲执行速度和与程序设计语言相关的类型长度而提供更高的编程创作能力和软件复用,**脚本语言都是动态语言,动态语言都是解释性语言**	脚本语言可以使用变量和函数

编译性语言的执行效率更高

 

动态语言:在程序运行时可以改变结构,新的函数被引进,已有的函数被删除等等.动态语言的类型检查在运行时进行,能够方便阅读,不需要写很多与类型相关的代码,缺点是不方便调试,命名不规范时会读不懂























































# 开发模型



## 瀑布模型	线性/里程碑

![image-20200828101620068](image.assets/image-20200828101620068.png)

三个阶段

* 定义

  ​	软件计划	可行性分析

  ​	需求分析	需求规格说明书

* 开发

​		软件设计	分为概要/详细设计 ,生成概要/详细设计说明书

​		程序编码	

​		软件测试	

* 维护

 		运行维护



适用于需求已明确的,很少需求变动

**测试在编码之后**,没有把测试提前



## V模型	重视测试

![image-20200828115201166](image.assets/image-20200828115201166.png)

单元测试以详细设计为依据,主要测试编码中的问题……以此类推

**验收测试由用户主导**

**并没有解决瀑布模型中测试过于靠后的问题** ,把测试放在了编码之后



## 喷泉模型

![image-20200828120852559](image.assets/image-20200828120852559.png)

**面向对象**

**每个阶段并没有明确的界限** ,能做到一定程度上并行,提高效率 ,从而**方便迭代**





## 原型化模型

用户难以表达需求 通过与用户沟通产生原型,用原型再与用户沟通 ,矫正为用户想要的模型

原型不能用于指导代码优化



探索型原型	探索模型

实验型原型	验证模型的正确性

演化型原型	演化出最终需要的产品



## 增量模型



==阶段化== ,==能快速构造可运行产品==

客户提出需求，并指出哪些需求是最重要的。

开发团队把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成， 并且能完成特定的功能。

* 优点

  * 能较短时间的交付

  * 逐步增加产品功能，用户有充裕的时间学习和适应新产品

  * 风险低；优先级最高的服务首先交付，然后依次将其他构件集成进来，这意味着==最重要的服务将接受最多的测试==

    





## 螺旋模型

![image-20200828121339936](image.assets/image-20200828121339936.png)

基于原型+瀑布	额外强调**风险分析**,提高了成本







## 统一过程



统一过程:	用例驱动/架构为中心/迭代和增量

四个阶段:

* 初始
  * 确定项目的**范围和边界**
  * 识别系统的**关键用例**
  *  展示系统的候选**架构**
  * 估计项目**费用和时间**
  * 评估项目**风险**

* 细化
  * 分析系统问题领域
  * 建立软件架构基础
  * 淘汰最高风险元素

* 构建
  * 开发剩余的构件		
  * 构件组装与测试

* 交付

  * 进行贝塔测试

  * 制作发布版本
  * 用户文档定稿
  * 确认新系统
  * 培训 ,调整产品



## 敏捷方法



敏捷方法中，**重构是**一种重新组织技术，重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求，可以**简化构件的设计而无需改变其功能或行为**



![image-20200828141616442](image.assets/image-20200828141616442.png)





* 自适应开发ASD     三个非线性,重叠的开发阶段 :猜测 ,合作 ,学习

* 水晶法            用**最少的纪律**约束 ,**经常交付**,每一种项目都要有**不同策略**
* 功用驱动开发FDD     短时间迭代 ,开发人员分为两类 ,首席程序员和类程序员
* 极限编程             费用控制严格
* 开放式源码     开发人员在地域上分布很广
* 并列争球SCRUM      明确**定义可重复**的方法过程 ,**迭代,增量交付**



### 4大价值观

沟通	简单	反馈	勇气



### 5大原则

快速反馈	简单性假设	逐步修改	提倡更改	优质工作



### 12大最佳实践

结对编程

集体代码所有制

隐喻			

简单设计:只处理当前需求,使设计保持简单

每周工作40小时

测试先行:先写测试代码,然后再编写程序

持续集成:可以随时为客户提供可运行的版本

现场客户:系统最终用户代表应全程配合xp团队

计划游戏:快速制定计划,随细节的变化不断完善

小型发布:系统的设计要尽可能早地发布

隐喻:找到合适的比喻传达信息

现场客户

重构

编码标准



### 基本原则

**短平快的会议**

**合作为重**

**客户直接参与**

**自动化测试**

小型版本发布

较少的文档

适应性计划调整

结对编程

测试驱动开发

持续集成

**重构**

















# 内聚/耦合



* 内聚	高->低
  * 功能内聚	完成单一功能,各个部分协同工作,缺一不可

  * 顺序内聚	处理元素相关,并且必须顺序执行
  * 通信内聚	所有处理元素集中在一个数据结构的区域上
  * 过程内聚	处理元素相关,按特定的次序执行
  * 瞬时内聚	所包含的任务必须在同一时间内运行
  * 逻辑内聚	完成逻辑上相关的一组任务
  * 偶然内聚	完成一组没有关系或松散的任务

* 耦合	低->高
  * 非直接耦合  没有直接关系,只通过主模块的控制和调用来实现
  * 数据耦合	通过参数交换信息
  * 标记耦合	通过参数表传递信息(数据结构)
  * 控制耦合	传递的信息中有控制信息
  * 外部耦合	访问公共的全局变量,不通过参数
  * 公共耦合	访问公共数据环境
  * 内容耦合	访问模块的内部信息



==模块被调用的次数越多 ,说明这个模块越独立==







# 开发方法



* 结构化方法	**面向数据流**  用数据流图描述
  * 用户至上
  * 严格区分工作阶段 ,每阶段有任务和结果
  * 强调系统开发过程的整体性和全局性
  * 系统开发过程工程化 ,文档资料标准化
  * **自顶向下 ,逐步分解** (精益求精)
  * **不适用于大型软件**
* 原型法
* 面向数据结构
  
* Jackson
  
* 面向对象方法    喷泉
  * 优点  复用性高,建立全面,合理,统一的模型
  * 缺点  分析 ,设计 ,实现三个阶段的界限不明确

* 面向服务方法SOA




## 统一过程



开发过程中有**多次迭代**，每次迭代都包含**计划、分析、 设计、构造、集成和测试，以及内部和外部发布**。

* 每个迭代有**五个核心工作流**
  * 捕获系统应该做什么的需求工作流
  * 精化和结构化需求的分析工作流
  * 在系统结构内实现需求的设计工作流
  * 构造软件的实现工作流
  * 验证是否如期望那样工作的测试工作流







## 应用工具

IPO图	输入处理输出图

PDL		程序描述语言(伪代码)

PAD		问题分析图

程序流程图	

N/S盒图					



PAD ,程序流程图 ,N/S盒图	三者可以互相转化 ,都用于分析问题



## 成本估计



Putnam和COCOMO都是软件成本估算模型。



* Putnam模型	**动态多变量**模型，强调在软件开发的整个生存期中工作量有特定的分布。



* COCOMO结构性成本模型
  * 基本COCOMO模型	静态单变量模型，对整个软件系统进行估算
  * 中级COCOMO模型	静态多变量模型，将软件系统模型分为**系统和部件两个层次**，系统由部件构成；
  * 详细COCOMO模型	将软件系统模型分为系统、子系统和模块三个层次，额外考虑了在**需求分析、软件设计等成本驱动属性**的影响。





# 需求分析



* 需求分析过程
  * 问题识别
  * 分析与综合
  * 需求分析文档
  * 需求分析与评审

* 需求分类
  * 功能
  * 非功能
  * 设计约束

* 应用工具
  * 数据流图 DFD
  * 数据字典 DD
  * 判定树
  * 判定表





# 测试



* 单元测试    ==模块内部==处理逻辑和结构
  * 调用模块的实参与被调用模块形参是否一致
  * 全局变量在模块中的定义和用法是否一致
  * 无法测出穿越模块的数据丢失,模块之间互相影响等问题

* 集成测试    ==模块间==的接口和通信

* 验收测试:    用户主导,β测试的一种

* 系统测试:    硬件,是否拥有能够运行的环境
* 回归测试:    已经测试过的,修改bug后再进行测试

* 负载测试:    最大负荷及响应的时间。

* 压力测试:    性能造成的影响





* 语句覆盖	所有判断都执行一次

* 判定/分支覆盖	true/false各一次

* 条件覆盖	判断中的条件都执行	
  * 条件为a>0&&b<0
    * a>0,b<0
    * a<0,b>0

* 判定/条件覆盖	true/false,条件,各一次

* 组合覆盖	每个条件的枚举,枚举的true/false都执行

* 路径覆盖





## 调试方法

* 归纳法：从测试所暴露的问题出发，收集所有正确或不正确的数据，分析他们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在。

* 试探法 

* 回溯法

* 对分查找法：前提条件:已经知道程序中的变量在若干位置的正确取值,可以用来缩小错误范围，

* 演绎法：根据测试结果，列出所有可能的错误；分析已有的数据，排除不可能和彼此矛盾的原因；对其余的原因，选择可能性最大的，利用已有的数据完善该假设，使假设更具体







# 软件维护



可理解性 ( 文档 )

可测试性

可修改性



* 维护类型
  * 改正性维护	25%	改正系统发布前的问题
  * 适应性维护	20%	环境发生变化 ,进行适应环境的修改
  * 预防性维护	5%		
  * **完善性维护**	50%	扩充功能 ,改善性能



## 维护文档



* 开发文档
  * 可行性研究和项目任务书
  * 需求规格说明
  * 功能规格说明
  * 设计规格说明 ( 包括程序和数据规格说明)
  * 开发计划
  * 软件集成和测试计划
  * 质量保证计划,标准 ,进度
  * 安全和测试信息

* 产品文档
  * 培训手册
  * 参考手册和用户指南
  * 软件支持手册
  * 产品手册和信息广告

* 管理文档
  * 开发过程的每个**阶段的进度和进度变更的记录**
  * 软件变更情况的记录
  * 相对与开发的判定记录
  * 职责定义



## 风险

风险曝光度 = 风险概率 * 损失



* 风险分析4个活动
  * 风险识别  系统化地确定对项目计划（估算、进度、资源分配）的威胁。
  * 风险预测/估算  从两个方面评估风险：概率,后果。
  * 风险评估  根据风险及其发生的概率和产生的影响预测是否影响 参考水平值。
  * 风险控制  辅助项目组建立处理风险的策略，有效的策略应考虑==风险避免==、风险监控、风险管理及意外事件计划。

风险控制同样考虑风险避免 ,**风险避免是最好的风险控制策略**





# 质量保证

* 功能性
  * 适合性
  * 准确性
  * 互操作性
  * 安全保密性
  * 功能性的依从性

* 可靠性
  * 成熟性
  * 容错性
  * 易恢复性
  * 可靠性的依从性

* 易用性
  * 易理解性
  * 易学性
  * 易操作性
  * 吸引性
  * 易用性的依从性

* 效率
  * 时间特性
  * 资源利用性
  * 效率依从性

* 维护性
  * 易分析性
  * 易改变性
  * 稳定性
  * 易测试性
  * 维护性的依从性

* 可移植性
  * 适应性
  * 易安装性
  * 共存性
  * 易替换性
  * 可移植的依从性



## 过程改进	软件成熟度CMMI

* ==4个方面==
  * 过程改进基础设施
  * 过程改进线路图
  * 软件过程评估方法
  * 软件过程改进计划

* ==5个等级==
  * 0 未完成级
  * 1 初始级
  * 2 可管理	纪律化的过程
  * 3 已定义	标准一致的过程
  * 4 定量管理	可预测的过程
  * 5 优化管理	不断改进

* ==每次改进经历4个步骤==
  * 评估、计划、改进和监控



# 项目管理	十大知识领域

* 范围管理
* **时间管理**
* 成本管理
* 质量管理
* 人力资源管理
* 沟通管理
* 风险管理
* 采购管理
* 整体管理
* 项目干系人管理



## 横道图 (甘特图)



![image-20200903220346675](image.assets/image-20200903220346675.png)

==粗线条代表计划		细线条代表实际==



## 关键路径

![](image.assets/PDM.png)



## 双代号网络图 ADM

![image-20200903221403126](image.assets/image-20200903221403126.png)



虚线代表虚工作 ,不占用时间和资源 ,只表示制约关系

































