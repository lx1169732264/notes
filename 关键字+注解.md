## 访问权限



![img](image.assets/wps3-1603184298721.jpg)

对于顶层的类/接口,应当设置 包级私有/公有

private	声明该类成员的顶层类内部

default	包内部的任何类

protected	声明该类的子类可访问

public	任何地方



public类的非final实例域决不能是公有的,这将放弃在这个域中存储的能力限制,任何地方都可以修改域中的值







### 继承的访问权限

==重写的访问修饰符只能比父类大==

Public继承	    不改变父类的访问权限

protected          private不变,其余都变为protected

private            都改成private



### 子类成员在外部的访问权限

**父类的private     只有父类能访问**

private方式继承的非private成员    只有子类的成员函数能访问,子类的子类/外部不能访问

protected方式继承的非private成员 	只有子类及子类的子类(非private继承) 能访问





## final

不能修饰构造方法

天生的==线程安全==



private方法会被隐式地指定为final

子类方法 和 基类private方法签名相同，则是在子类中定义了新方法,而不是重写



| 类       | 方法     | 基本类型   | 引用类型                                                 |
| -------- | -------- | ---------- | -------------------------------------------------------- |
| 不能继承 | 不能重写 | 不能改变值 | 不能指向新对象,引用对象的所有成员方法被隐式地指定为final |



```java
 final Dog dog = new Dog("aa");
 dog.name = "bb";//正确
 dog = new Dog("cc");//错误
```





## static

1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名`    `类名.静态方法名()`
2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法



### static VS 成员变量



|          | static变量       | 成员变量             |
| -------- | ---------------- | -------------------- |
| 生命周期 | 类加载 -> 类卸载 | 对象创建 -> 对象回收 |
| 调用方式 | 对象/类调用      | 对象调用             |
| 存储位置 | 方法区,1个       | 堆,多个              |
|          |                  |                      |



static不代表不可修改,它是能够时刻保持最新的值的静态变量

==静态是指不会随着函数的调用/退出发生变化==。下次调用时，这个值与上次调用一致

==static final全局常量才不能修改==



static方法从类加载便存在,所以必须有实现





## this / super

this指向引用类的当前实例

super指向父类对象



构造器中使用super需要放在首行



**this和super不能在static方法中使用**,都是指向了对象,而static属于类





## native



```
@Documented
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.SOURCE)
public @interface Native {}
```

native是**java调用非java代码的接口**,定义Native Method时,**并不需要提供实现**

调用者不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节

子类可以继承本地方法并用java重写	**本地方法被fianl标识，继承后不能被重写**



==native可以与所有修饰符连用，除abstract==,与abstract的无实现相违背

==native method可以返回任何java类型，包括非基本类型==，可以进行异常控制。这些方法的实现体可以制一个异常并且将其抛出。当native method接收到非基本类型,可以访问非基本类型的内部，**但这将使native method依赖于所访问的java类的实现**



==JVM怎样使Native Method跑起来==
当类第一次被使用时，这个类的字节码会被加载到内存。在这个被加载的字节码入口,维持着该类所有方法描述符的list，这些方法描述符包含：方法代码存储地址，参数，修饰符等
native修饰符将有指向该方法实现的指针。这些实现在一些DLL文件内，会被操作系统加载到java程序的地址空间。当带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。**当本地方法被调用之前，这些DLL才会被加载**，通过调用java.system.loadLibrary()实现





## Switch



1.5前，只能是byte，short，char，int类型(或其包装类)的常量表达式

1.5后，引入枚举enum

1.7后，exper还可以是String类型。

**long在所有版本都不行**



1.7通过hashCode(),将string转换为int,switch(String)只是语法糖,在相应位置插入了强制转换代码，底层并没有修改

==Switch中的String必须先判空==

```java
//在编译后的class中
String string = "Hello";
String s;
switch ((s = string).hashCode()){
  case 2301506: 
    //用equals进行安全检查（避免hash相同值不同）
    if (!s.equals("Java"))
```



每个case要么通过continue/break/return等来终止，要么注释说明程序将继续执行到哪一个case为止



==对于case不需要break时,必须写注释,解释为何不需要break==

必须包含一个default语句并且放在最后









# 注解





## Lombok



@EqualsAndHashCode

默认使用非静态，非瞬态的属性

参数exclude排除属性	参数of指定仅使用哪些属性

默认callSuper=false	仅使用类中定义的属性,不调用父类属性和方法





## @Mapper



```java
@Mapper(unmappedTargetPolicy = ReportingPolicy.ERROR) //unmappedTargetPolicy 对于未映射成功属性的警告策略
public interface QwDeptConvert {

  QwDeptConvert INSTANCE = Mappers.getMapper(QwDeptConvert.class);

  @Mappings({ //映射策略
    @Mapping(target = "id", ignore = true), //指定不需要映射的字段
    @Mapping(source = "name", target = "customerName") //指定来源和目标
  })
  QwDept fromCreateQwDeptCmd(CreateQwDeptCmd command);

  @Mappings({
    @Mapping(target = "children", expression = "java( new java.util.ArrayList<com.darcytech.typhon.qywechat.qwdeptstaff.dto.QwDeptTreeDto>())")
  })
  QwDeptTreeDto toQwDeptTreeDto(QwDept qwDept);
}
```























































## JSON

@JsonInclude(Include.NON_NULL) 是springmvc中的标注，剔除返回json中的null

@JsonIgnore	忽略不想传给前台的的属性





//将该标记放在属性上，如果该属性为NULL则不参与序列化 
//如果放在类上边,那对这个类的全部属性起作用 
//Include.Include.ALWAYS 默认 
//Include.NON_DEFAULT 属性为默认值不序列化 
//Include.NON_EMPTY 属性为 空（“”） 或者为 NULL 都不序列化 
//Include.NON_NULL 属性为NULL 不序列化 











## Junit注解

@BeforeClass – 表示在类中的任意public static void方法执行之前执行

@AfterClass – 表示在类中的任意public static void方法执行之后执行

@Before – 表示在任意使用@Test注解标注的public void方法执行之前执行

@After – 表示在任意使用@Test注解标注的public void方法执行之后执行

@AfterRunning: 返回通知, 在方法返回结果之后执行

@AfterThrowing: 异常通知, 在方法抛出异常之后

@Around: 环绕通知, 围绕着方法执行

 





## @Repeatable

在没有`@Repeatable`注解的的注解中，在同一个地方使用相同的注解会报错，有了此元注解注解的注解，就可以在同一个地方使用相同的注解

```java
@Value("hello")
@Value("world")
public void test(String var1, String var2) {
  System.out.println(var1 + " " + var2);
}
```













