# 常用注解

pojo是一个统称，可以是DTO、可以是VO、可以是PO、可以是domain，这些都叫pojo
 po、do、domain三者区别很小，用处都是和数据库进行对应

DTO是数据传输对象，简单点说就是传参数用的。比如一张表30个字段，但是传参的时候只需要传5个字段，这个时候使用dto，可以避免过多的无用数据，也可以隐藏后端表结构，往往是前端传参给后端、controller、service、dao三层之间传递使用。
 VO就是view Object，专门负责给前端展示数据。VO是业务对象，业务上需要什么字段它就给什么字段，比如上面说的学生表，在给前端展示的时候需要展示名称：class_name这个字段，那么vo里写的就不是classId，而是className或者班级类

 

do、vo、dto这些类之间不需要给继承关系，从设计思想来讲也不能给继承关系。互相之间的属性复制使用spring提供的BeanUtils.copyProperties。如果是集合这种数据较多的属性复制，就先转成json字符串再转成另一个类的List

 

@Deprecated，用来表示某个类或属性或方法已经过时

@SuppressWarnings用来压制程序中出来的警告，比如在没有用泛型或是方法已经过时的时候



## Junit注解

@BeforeClass – 表示在类中的任意public static void方法执行之前执行

@AfterClass – 表示在类中的任意public static void方法执行之后执行

@Before – 表示在任意使用@Test注解标注的public void方法执行之前执行

@After – 表示在任意使用@Test注解标注的public void方法执行之后执行

@AfterRunning: 返回通知, 在方法返回结果之后执行

@AfterThrowing: 异常通知, 在方法抛出异常之后

@Around: 环绕通知, 围绕着方法执行

 

 

# 日期格式处理

@JsonFormat           后台到前台

properties文件中有相同的配置spring.mvc.date-format

@DateTimeFormat     前台到后台

properties文件中有相同的配置spring.jackson.date-format

spring.jackson.time-zone

 

@Respostory

@Compment      把切面类加入到IOC容器中

@**EnableAspectJAutoProxy**   //开启对AspectJ语法风格的支持

@ControllerAdvise  当Controller出现异常时,跳转页面

@RestControllerAdvise         ,返回json

 

@bean作用在方法上

@import引入其他的配置文件 

@ComponentScan(“”) 配置扫描

 

当ioc容器里有多个同名对象时

@Qualifier 合格者，表明哪个bean是需要的

​    Qualifier的参数必须是之前用@Bean注解过的

@Primary  指明优先级

 

@Configuration(proxyBeanMethods = false) proxyBeanMethods决定了配置类是否会被代理,如果@Bean方法间没有调用关系的话可以把 proxyBeanMethods 设置为 false。否则，方法内部引用的类生产的类和 Spring 容器中类是两个类。

 

 

@ConditionalOnBean // 当给定的在bean存在时,则实例化当前Bean @ConditionalOnMissingBean // 当给定的在bean不存在时,则实例化当前Bean @ConditionalOnClass // 当给定的类名在类路径上存在，则实例化当前Bean @ConditionalOnMissingClass // 当给定的类名在类路径上不存在，则实例化当前Bean

 

 

@ConfigurationProperties(prefix = "spring.redis") 配置类注解,prefix是配置时的前缀

@EnableConfigurationProperties(RedisProperties.class)     加载配置类

 

 

**@Lazy**   **懒加载**

***注入userService时,CacheAspect中自定义的切面增强还没有被加载
 导致注入进去的是还未被动态代理的,原生的userService\***

 

***@TableField(exist = false)\***  ***实体类中,数据库不存在的字段需要加上这个注解\***

 

@Transactional 	**public 的方法才起作用**

1)事务开始时，通过AOP机制，**生成代理connection对象**，并将其放入DataSource实例的某个与DataSourceTransactionManager相关的容器中。客户代码使用该connection连接数据库，执行所有数据库命令

2)事务结束时，回滚代理connection对象上执行的数据库命令，然后关闭该代理connection对象（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用）

## 五大元注解

### @Target：限制注解能修饰的对象范围

/**用于描述类、接口(包括注解类型) 或enum声明*/

  TYPE,

  /** 用于描述域 Field declaration (includes enum constants) */

  FIELD,

  /**用于描述方法 Method declaration */

  METHOD,

  /**用于描述参数 Formal parameter declaration */

  PARAMETER,

  /**用于描述构造器 Constructor declaration */

  CONSTRUCTOR,

  /**用于描述局部变量 Local variable declaration */

  LOCAL_VARIABLE,

  /** 注解类 */

  ANNOTATION_TYPE,

  /**用于描述包 Package declaration */

  PACKAGE,

  /**用来标注类型参数 Type parameter declaration   */

  TYPE_PARAMETER,

  /**所有类型 */

  TYPE_USE

### @Retention 

Retention注解有一个RetentionPolicy类型的枚举属性

有3个值：CLASS RUNTIME  SOURCE标明注解应该如何去保持,这也是它的生命周期
 RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；
 RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，默认RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；
 这3个生命周期分别对应于：Java源文件(.java文件) ---> .class文件 ---> 内存中的字节码。


生命周期长度 SOURCE < CLASS < RUNTIME ，所以前者能作用的地方后者一定也能作用。
 需要在运行时动态获取注解信息，那只能用RUNTIME注解，比如@Deprecated使用RUNTIME注解
 在编译时进行预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；
 只是检查性的操作，比如 @Override 和 @SuppressWarnings，使用SOURCE 注解。

### @Documented将注解包含在javadoc中

默认情况下，javadoc是不包括注解的，但如果使用了@Documented注解，则相关注解类型信息会被包含在生成的文档中

### @Inherited指明父类注解会被子类继承得到

### @Repeatable

指明注解为可重复注解，可以在同一个地方多次使用

## @Scheduled定时

八大参数

### Cron 定时时间

@Scheduled(cron = "0 0 5 * * ?")      [秒] [分] [小时] [日] [月] [周] [年]

允许正则表达式,

?    不指定值

\-    区间

,    指定多个值

/    递增触发。秒”5/15” 表示从5秒开始，每增15秒触发

L    最后。对于日字段，表示当月的最后一天.对于周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”

W   离指定日期的最近的工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。

\#    序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置

’L’和‘W’组合使用。在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。

### zone时区.一般留空

fixedDelay上一次执行完毕后多长时间再执行

@Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行

fixedDelayString 同上的字符串形式,支持占位符

@Scheduled(fixedDelayString = "5000") //上一次执行完毕时间点之后5秒再执行
 fixedRate上一次开始执行后多长时间再执行

@Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行

fixedRateString同上的字符串形式。支持占位符

initialDelay第一次延迟多长时间后再执行

@Scheduled(initialDelay=1000, fixedRate=5000) //第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次

initialDelayString同上的字符串形式。支持占位符







# Environment类(Spring自身的类)

可以把Spring应用的运行时分成两个部分：一个是Spring应用本身，一个是Spring应用所处的环境。

定时注解@Scheduled有时需要获取当前的运行环境(用户信息,配置文件信息等)

Environment在容器中是一个抽象的集合，是指应用环境的2个方面：profiles和properties。

\1. Profile

  不管是XML还是注解，Beans都有可能指派给profile配置。Environment环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。

\2. Properties

  properties来源于properties文件、JVM properties、system环境变量、JNDI、servlet context parameters上下文参数、专门的properties对象，Maps等等。对于properties来说，Environment对象可以提供给用户方便的服务接口、方便撰写配置、方便解析配置。
     environment.getProperty获取配置文件中的属性

 







## unreachable code编译错误

Java检查到他们后面的语句都无法执行下去，

* 跳到下一次循环或其他地方
* 死循环，无法执行下一句



Checked exception:这类异常都是Exception的子类 

Unchecked exception: 这类异常都是RuntimeException的子类







# 调试助手



## 创建指定大小文件

在目录下进入cmd

fsutil file createnew test.txt 字节数









 

# REST

## 无状态stateless

在请求中传递SessionID被普遍认为是unRESTful的，而将用户的credentials(认证信息)包含在每个请求里又是一种非常RESTful的做法。这样一个问题经常会造成困扰。本文就REST的一些概念进行了探讨，解释了REST架构中的状态，无状态（stateless），以及两种状态的区别

“状态”通常指的是为两个相互关联的用户交互操作保留的某种公共信息，它们常常被用来存储工作流或用户状态信息等数据。这些信息可以被指定不同的作用域如page，request，session或全局作用域，而存储他们的责任也同样可以由Client端或Server端负责。虽然存储状态为企业软件开发带来了诸多便利，但是它也给分布式系统的其他方面带来了许多限制，比如在负载均衡方面，在有状态的模式下，一个用户的请求必须被提交到保存有其相关状态信息的服务器上，否则这些请求可能无法被理解，这也就意味着在此模式下服务器端无法对用户请求进行自由调度。于此相关的另一个问题是容错性，倘若保有用户信息的服务器宕机，那么该用户最近的所有交互操作将无法被透明地移送至备用服务器上，除非该服务器时刻与主服务器同步全部用户的状态信息。此外，由于HTTP本身不是一个有状态的协议，开发人员必须通过模拟实现状态的钝化与激活等。

无状态指的是任意一个Web请求必须完全与其他请求隔离，当请求端提出请求时，请求本身包含了相应端为相应这一请求所需的全部信息。这一约束的出现改善了分布式系统的可见性、可靠性以及可伸缩性。如果一个网站期望用户以A->B->C的流程来交互，而在执行至B时回退的话，那么系统很有可能不是按照其所期望的方式运行，因为用户的状态可能被不可逆地修改了。反过来，任何用户可以在浏览器地址栏中输入http://www.google.com/search?q=RESTful&start=100来获得从第一百条开始的关于RESTful的记录，并且当Google服务器瘫痪时，相关用户请求会被透明地移送至其他服务器。

​     RESTful架构对于state的两个不同的解释: 应用状态(Application State)和资源状态(Resource State)。应用状态指的是与某一特定请求相关的状态信息，而资源状态则反映了某一存储在服务器端资源在某一时刻的特定状态，该状态不会因为用户请求而改变，任何用户在同一时刻对该资源的请求都会获得这一状态的表现（Representation）。RESTful架构要求服务器端不保有任何与特定HTTP请求相关的资源，所以应用状态必须由请求方在请求过程中提供。那么为什么传递一个session ID是违背REST架构风格而传递user credentials却不是。实际上“传递某种表示状态的信息”到服务器不是“有状态”的表现。其实有状态和无状态与请求本身没有多大关联，重要的是状态信息是由请求方还是响应方负责保存。在Session ID可以被认为是一个用来标识某一会话状态的Key，将其传递给服务器端意味着这样一个请求：“请帮我取出这个状态信息”，也就是说这个请求假设响应方保有着状态信息。由于与某一特定请求相关的状态属于应用状态，而RESTful架构要求任何此类状态由请求方负责提供，所以传递Session ID被认为是unRESTful的做法。反过来，user credential作为一种应用状态，是被期望由请求方提供的，所以在请求中传递user credentials是符合RESTful架构规范的。