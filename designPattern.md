# 工厂设计模式：
由一个工厂类根据传入的参数（一般是字符串参数），动态决定应该创建哪一个产品子类（这些产品子类继承自同一个父类或接口）的实例，并以父类形式返回
优点：客户端不负责对象的创建，而是由专门的工厂类完成；客户端只负责对象的调用，实现了创建和调用的分离，降低了客户端代码的难度；
缺点：如果增加和减少产品子类，需要修改简单工厂类，违背了开闭原则；如果产品子类过多，会导致工厂类非常的庞大，违反了高内聚原则，不利于后期维护

# 饿汉单例模式

在类加载的时候创建实例，而不是等到第一次请求实例时创建

私有的无参数构造方法，避免外部创建实例

私有静态属性instance

公有静态方法getInstance()



# 懒汉单例模式

在类加载的时候不创建单例实例，只有在第一次请求实例时创建



# 适配器模式
两个不兼容的接口之间的桥梁,结合了两个独立接口的功能.这种模式涉及到一个单一的类，该
类负责加入独立的或不兼容的接口功能。
属于结构型模式
# 模板模式
一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行









# 编程原则
## 单一职责原则：
高内聚:一个类只做它该做的事情。一个代码模块只完成一项功能，而不涉及与它无关的领域
模块化，每个功能模块是可以轻易的拿到其他系统中使用的，这样才能实现软件复用
## 开闭

软件实体应当对扩展开放，对修改关闭。要做到开闭有两个要点：

①抽象是关键，没有抽象类或接口就没有扩展点；
②封装可变性，将系统中的各种可变因素封装到一个继承结构中
## 依赖倒转

面向接口编程。（声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代）

## 里氏替换

任何时候都可以用子类型替换掉父类型。子类一定是增加父类的能力而不是减少父类的能力

## 接口隔离

接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。

## 合成聚合复用

优先使用聚合或合成关系复用代码。（类与类之间简单的说有三种关系，IS-A、HAS-A、USE-A，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 HAS-A 关系

## 迪米特/最少知识原则

一个对象应当对其他对象有尽可能少的了解。（“低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）

